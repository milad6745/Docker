سینتکس داکر فایل:
برای نوشتن داکر فایل، فایلی رو با نام Dockerfile و بدون پسوند ایجاد می‌کنیم و داخل اون دستورات داکر فایل رو می‌نویسیم. البته می‌تونه اسمش این نباشه ولی این اسم پیش‌فرضی هست که می‌شناسه و وقتی این اسم رو براش انتخاب می‌کنیم به راحتی می‌شناسه و سینتکس هایلایت بهمون می‌ده. یک نکته اینکه سینتکس داکرفایل رو به صورت UpperCase همواره در ابتدای خط نوشته می‌شه. می‌تونه به صورت LowerCase هم باشه ولی نرمال اینه که به صورت UpperCase نوشته بشه.

در ادامه لیستی از گزینه هایی که تو داکر فایل استفاده میشه رو با یه توضیح مختصر ازشون براتون میارم و تو اینجا هم می‌تونید رفرنس کاملش رو داشته باشید.

.dockerignore:

معمولا ما Dockerfile رو کنار دایرکتوری و فایل های پروژه مون میذاریم و مثلا دستوراتی میزنیم که فایل هامون رو کپی کنیم توی ایمیج یا کارهای مشابه. حالا اگه فایلی با نام dockerignore. توی پروژه کنار داکر فایل باشه میتونیم داخلش لیستی از فایل ها و دایرکتوری هایی رو که میخوایم داخل داکرفایل نباشه رو مشخص کنیم. مفهومی شبیه gitignore. اگه باهاش آشنا باشید. قبلا این طوری بود که تمام فایل‌ها و دایرکتوری‌هایی که کنار داکرفایل بود رو تو ایمیج لود می‌کرد که الان با این بیلد‌کیت جدیده دیگه این اتفاق نمی‌افته ولی هنوز این امکان وجود داره که خودمون یه سری فایل رو ignore کنیم تا داخل داکرفایلمون نباشه.

FROM:

همونطور که بالاتر هم گفتم هر ایمیجی از یه بیس ایمیج شروع میشه. بنابراین هر داکر فایلی رو که باز می‌کنیم اولش یه FROM هست که اون بیس ایمیج رو مشخص کنه. حالا ممکنه ماجرای مرغ و تخم مرغ ابهامش تو ذهنتون ایجاد شه که خب اون بیس ایمیج‌مون که توی خط اول داکر فایلش نوشته FROM خودش از روی چه ایمیجی ساخته شده؟ پاسخ scratch هست که میتونید در موردش بیشتر بخونید. یعنی base image‌ها از From scratch ساخته می‌شوند.

MAINTAINER:

یه جورایی تو این قسمت که نقش متا دیتا داره یه سری اطلاعات در مورد نویسنده داکر فایل رو می‌نویسن که این کار بهمون کمک می‌کنه که بتونیم نویسنده‌ی آن رو مشخص کنیم تا بتونیم اگر لازم شد باهاش ارتباط بگیریم. دیگه دیپریکیت شده و ازش استفاده نمی‌شه و به جای آن از لیبل استفاده می‌شه تا مشخص کنیم که نویسنده‌ی داکرفایل چه کسی بوده.

RUN:

یکی از مهمترین سینتکس‌های داکرفایل، با این دستور یک لایه جدید بالای ایمیج درست میشه و کامندی که زدیم توی اون لایه اجرا میشه و نتایج کامند توی اون ذخیره میشه. به صورت کلی هر اکشنی که تو ایمیج می‌خواهیم بزنیم رو با استفاده از RUN انجامش می‌دیم. دقت کنید RUN در زمان ساخت ایمیج اجرا می‌شه و هر RUN یک لایه‌ی جدید تو ایمیج ایجاد می‌کنه.

CMD:

تو کانتینرها چون خیلی سبک و کم‌حجم ساخته می‌شوند سرویسی نداریم شبیه systemd لینوکس که بیاد سرویس‌های دیگه رو تو بک‌گراند ران کنه و بالا نگه داره. برای همین باید خودمون سرویس‌هایی که لازم داریم رو تو Forground بالا نگه داریم. CMD کارش اینه که باهاش ما سرویس‌های خودمون رو تو Forground بالا نگه می‌داریم. دقت کنید که CMD در زمان تبدیل ایمیج به کانتینر اجرا می‌شه.

EXPOSE:

این گزینه علاوه بر اینکه کمک می‌کنه که نشون بدیم وقتی کانتینر بالا میاد چه پورتی رو لیسن می‌کنه و یه جورایی متادیتا هست بهمون کمک می‌کنه که زمانی که docker ps می‌زنیم تو قسمت پورت‌ها، پورتی که داخل کانتینر قراره لیسن بشه رو نشون بده.

ENV:

متغیرهای محیطی ایمیج‌مون رو اینجا تعریف می‌کنیم. متغیرهایی که بعدا در زمان کانتینر هم وجود داره و اگر داخل کانتینر env بزنیم می‌تونیم آنها رو ببینیم.

COPY:

برای کپی کردن فایل‌ها و دایرکتوری‌ها از لوکال سرور ازش استفاده می‌کنیم. همانند RUN یک لایه‌ی جدید ایجاد می‌کنه و روش Official کپی‌ فایل داخل ایمیج هستش.

ADD:

برای انتقال و کپی کردن فایل ها و دایرکتوری هامون به صورت لوکال یا ریموت فایل ازش استفاده می‌کنیم. ADD هم همانند COPY و RUN یک لایه ایجاد می‌کند. تنها تفاوتی که ADD برامون داره اول اینکه از ریموت مثل گیت می‌تونیم فایل داخل ایمیج قرار بدیم و دوم اینکه فایل‌های Compress شده رو هم می‌تونه برامون در حین انتقال از Compress خارج کنه.

ENTRYPOINT :
گاهی پیش میاد که راه‌اندازی پروسه‌ی ما فقط با یه دستور نیست و نیاز داریم که براش یه اسکریپت اجرا کنیم. اینجا می‌تونیم از این سینتکس استفاده کنیم. در برخی از مواقع هم پیش میاد که همزمان با CMD ازش استفاده می‌شه. همانند CMD این سینتکس هم در زمان تبدیل ایمیج به کانتینر اجرا می‌شود. بیشتر برای پروسه‌هایی که نیاز به bootstrapping دارند کاربرد دارد.

VOLUME:

تو این سینتکس داریم مشخص می‌کنیم که دیتاهای حساس ما کجاها قرار دارند. علاوه بر اینکه داریم به فردی که داکرفایل رو می‌خونه می‌گیم که برای این مسیر باید در زمان کانتینر والیوم بسازی و یه جورایی نقش متادیتا رو بازی می‌کنه اگر فرد براش والیوم نساخت یه والیوم با نام رندم ایجاد می‌کنه که یک آی‌دی بهش می‌ده و دیتا رو اونجا Persist می‌کنه. یعنی اگر براش والیوم ساخت و این مسیر رو آنجا مانت کرد که هیچ اگر نساخت خود داکر با توجه به داکرفایل براش می‌سازه.

USER:

هر کاربری که مشخص کنیم در ادامه‌ی ایمیج و در زمان کانتینر با آن کاربر کار می‌کنه. این نکته‌ی مهمی است و جز Best Practiceهای داکرفایل هم هست که نباید ایمیج با کاربر Root باشه و اصطلاحا باید root less باشه.

WORKDIR:
دایرکتوری کاریمون رو مشخص می‌کنه. در ادامه‌ی ایمیج و در زمان کانتینر تو این مسیر دستورات رو می‌زنه و ادامه می‌ده. این دستور هم همانند RUN, COPY و ADD یک لایه‌ی جدید برای ما ایجاد می‌کنه.

ARG:

وریبل های زمان بیلدمون رو اینجا مشخص می‌کنیم. این خاصیت رو داره که به وریبل یه مقدار دیفالت رو بدیم و در زمان بیلد آن آرگومان رو به فراخور نیازمون تغییر بدیم. اگرم ندادیم که مقدار دیفالت رو برمی‌داره. نکته‌‌ای که داره تنها سینتکسی هست که قبل از FROM می‌تونه قرار بگیره.

ONBUILD:

دستور تریگری رو اینجا مشخص می‌کنیم که موقعی‌که داکر فایل دیگه‌ای از ایمیج ما به عنوان بیس ایمیج استفاده کرد براش اعمال شه. یعنی زمانی کاربرد داره که این ایمیج خودش به عنوان Base Image استفاده بشه.

STOPSIGNAL:

اینجا سیگنال سیستم کالی رو که باید برای خروج به کانتینر فرستاده بشه رو مشخص می‌کنیم. یعنی وقتی که دستور kill برای کانتینر ارسال می‌شه اون چه طوری بمیره. واقعا خیلی مهم که کانتینر ما چطوری بمیره. مثلا اینکه وقتی kill براش ارسال شد در لحظه بمیره یا صبر کنه و تمام درخواست‌هایی که سمتش هست رو پاسخ بده و بعد بمیره یا اصلا reload بشه.

LABEL:

اینجا میتونیم متادیتا‌هایی که دوست داریم رو در قالب کلید و مقدار برای ایمیج و کانتینرمون اضافه کنیم. خوبه که لیبل‌های مناسبی قرار بدیم تا کسی که با ایمیج کار می‌کنه بتونه از آنها استفاده کنه. مثلا یکیش اینکه نویسنده‌ی داکرفایل چه کسی هست و اطلاعات ارتباط باهاش رو قرار بدیم.

HEALTHCHECK:

اینجا میتونیم برای داکر مشخص کنیم که به چه شکلی چک کنه که کانتینری که از روی ایمیج ما بالا اومده هنوز داره کار میکنه یا اینکه کارش تموم شده و باید بمیره. یه جورایی داریم مشخص می‌کنه که وضیعت سالم و اوکی از نظر این کانتینر چی هست. دو تا مرحله داره مرحله اول starting و مرحله‌ی دوم Healthy یا Unhealthy هست.

SHELL:

اینجا هم میتونیم شل دیفالتی که برای کامند هامون وجود داره رو overwrite کنیم. به صورت پیش‌فرض معمولا shell رو از base image می‌گیره و اینجا ما می‌تونیم مشخص کنیم که دقیقا چی باشه. دقت کنید این موضوع هم همانند برخی دیگه از سینتکس‌ها در ادامه‌ی ایمیج و در زمان کانتینر اعمال می‌شه.

یه نمونه از داکرفایل یک app flask رو اینجا براتون میذارم:
